package com.github.dzirbel.battlecompanion.core

import kotlin.random.Random

/**
 * Represents the state of the combat board at a specific time, which simply contains the [attackers] and [defenders].
 * Note that since [Army] is immutable, [Board] is as well.
 * TODO submarine submerging
 * TODO attackers retreating
 * TODO listener system
 */
data class Board(
    val attackers: Army,
    val defenders: Army
) {

    /**
     * Gets the outcome of the combat on this [Board], or null if the battle is not decided.
     */
    fun getOutcome(): Outcome? {
        return when {
            attackers.isEmpty() && defenders.isEmpty() -> Outcome.Tie
            attackers.isEmpty() && !defenders.isEmpty() -> Outcome.DefenderWon(defenders)
            !attackers.isEmpty() && defenders.isEmpty() -> Outcome.AttackerWon(attackers)
            else -> null
        }
    }

    /**
     * Determines whether this [Board] is undergoing an amphibious assault, which is currently true when the [attackers]
     *  have a [UnitType.BATTLESHIP] and the [defenders] have any land units.
     * TODO think this through - BOMBARDING_BATTLESHIP special unit, etc?
     */
    fun isAmphibiousAssault(): Boolean {
        return attackers.units.any { it.key == UnitType.BATTLESHIP } &&
                defenders.units.any { it.key.domain == Domain.LAND }
    }

    /**
     * Conducts a round of combat (including both opening and regular fire) based on the rolls generated by the given
     *  [Random] and returns a [Board] with the result.
     * Units which only fire once (i.e. bombarding battleships and defending antiaircraft guns) are also removed from
     *  the returned [Board] after firing.
     */
    fun roll(rand: Random): Board {
        return runRound(rand, isOpeningFire = true).withoutOnetimeUnits().runRound(rand, isOpeningFire = false)
    }

    /**
     * Returns a copy of this [Board] without [UnitType]s that should only fire once in the battle, i.e. bombarding
     *  battleships and defending antiaircraft guns.
     */
    private fun withoutOnetimeUnits(): Board {
        return Board(
            attackers = if (isAmphibiousAssault()) attackers.withoutType(UnitType.BATTLESHIP) else attackers,
            defenders = defenders.withoutType(UnitType.ANTIAIRCRAFT_GUN)
        )
    }

    /**
     * Runs a round of combat on this [Board] in which the attackers and defenders exchange hits based on the rolls
     *  generated by the given [Random] and returns a [Board] with the result.
     */
    private fun runRound(rand: Random, isOpeningFire: Boolean): Board {
        val currentAttackers = if (isOpeningFire) {
            attackers.withOpeningFire(board = this, isAttacking = true)
        } else {
            attackers.withoutOpeningFire(board = this, isAttacking = true)
        }

        val currentDefenders = if (isOpeningFire) {
            defenders.withOpeningFire(board = this, isAttacking = false)
        } else {
            defenders.withoutOpeningFire(board = this, isAttacking = false)
        }

        // note that both attacker and defender hits must be rolled before taking casualties on either side to ensure
        // they are done in parallel
        val attackerHits = currentAttackers.rollHits(rand, isAttacking = true)
        val defenderHits = currentDefenders.rollHits(rand, isAttacking = false)

        return Board(
            attackers = attackers.takeHits(defenderHits),
            defenders = defenders.takeHits(attackerHits)
        )
    }
}
